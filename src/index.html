<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>TubeTally — Irrigation Row Counter</title>
  <meta name="theme-color" content="#10B981" />
  <link rel="manifest" href="./manifest.json" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./icon.svg">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --green: #10B981;
      --red: #EF4444;
      --yellow: #F59E0B;
      --bg: #ffffff;
      --fg: #111827;
      --card: #ffffff;
      --cardBorder: #e5e7eb;
    }

    .dark {
      --bg: #0b0b0c;
      --fg: #e5e7eb;
      --card: #141417;
      --cardBorder: #26272b;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100svh;
      padding-bottom: env(safe-area-inset-bottom);
    }

    #mainContent {
      display: flex;
      flex: 1;
      overflow: hidden;
      gap: 1rem;
      padding: 0 1rem 1rem 1rem;
    }

    .column {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }

    #app.flip-layout #mainContent {
      flex-direction: row-reverse;
    }

    .btn {
      border-radius: 1rem;
      font-weight: 800;
      box-shadow: 0 6px 14px rgba(0, 0, 0, .08);
      transition: transform .05s;
    }

    .btn:active {
      transform: scale(.98);
    }

    .icon-btn {
      border-radius: .75rem;
      background: #f3f4f6;
      color: #111827;
      padding: .5rem .75rem;
      display: flex;
      align-items: center;
      gap: .5rem;
    }

    .dark .icon-btn {
      background: #1f2937;
      color: #f3f4f6;
    }

    .card {
      border: 1px solid var(--cardBorder);
      background: var(--card);
      border-radius: 1rem;
    }

    /* History row styles: fixed-width right-aligned numbers and non-wrapping status badges */
    .history-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .history-number {
      width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Segoe UI Mono', monospace;
    }

    .history-badge {
      display: inline-block;
      white-space: nowrap;
      padding: .25rem .6rem;
      font-weight: 700;
      border-radius: .5rem;
      font-size: .95rem;
    }

    /* Compact stat badges shown under history: 3-digit padded numbers */
    .stat-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 3ch;
      padding: .12rem .4rem;
      border-radius: .5rem;
      font-weight: 800;
      font-size: .95rem;
      white-space: nowrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Segoe UI Mono', monospace;
    }
    .saved-field-item {
      border: 1px solid var(--cardBorder);
      background: var(--card);
      border-radius: 0.9rem;
      padding: 0.65rem;
      cursor: pointer;
      transition: border-color .15s, box-shadow .15s, transform .08s;
    }
    .saved-field-item:hover {
      border-color: rgba(16, 185, 129, 0.6);
    }
    .saved-field-item:active {
      transform: scale(.99);
    }
    .saved-field-item.active {
      border-color: var(--green);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
    }
    .saved-field-empty {
      border: 1px dashed var(--cardBorder);
      border-radius: 0.9rem;
      padding: 1rem;
      text-align: center;
      font-size: .85rem;
      opacity: .7;
    }
    #saveFieldBtn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    #viewModeBadge {
      background: rgba(107, 114, 128, 0.18);
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-weight: 700;
      font-size: .75rem;
    }
    dialog {
      border: none;
      color: var(--fg);
    }
    dialog form,
    dialog > div {
      background: var(--card);
      color: var(--fg);
    }

    #toast {
      position: fixed;
      left: 50%;
      bottom: calc(env(safe-area-inset-bottom) + 12px);
      transform: translateX(-50%);
      background: #111827;
      color: #fff;
      padding: .55rem .8rem;
      border-radius: .75rem;
      font-size: .875rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s;
      z-index: 50;
    }

    .show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="app" class="select-none">
    <!-- TOP BAR -->
    <header class="flex justify-between items-center p-3 flex-none">
      <div class="flex items-center gap-2">
        <img src="./icon.svg" alt="TubeTally" class="w-8 h-8" />
        <h1 class="text-xl font-extrabold">TubeTally <span id="appVersionLabel" class="text-xs font-normal align-top opacity-60">v1.6</span></h1>
      </div>
      <div class="flex items-center gap-4">
        <button id="savedFieldsBtn" class="icon-btn" title="Saved fields" aria-label="Saved fields">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
            <path d="M3 10h18"></path>
            <path d="M8 4v4"></path>
          </svg>
          <span class="hidden sm:inline">Saved</span>
        </button>
        <button id="shareBtn" class="icon-btn" title="Share report" aria-label="Share">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
          <span class="hidden sm:inline">Share</span>
        </button>
        <button id="resetBtn" class="icon-btn" title="New field" aria-label="New field">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="1 4 1 10 7 10"></polyline>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
          </svg>
          <span class="hidden sm:inline">New</span>
        </button>
        <button id="settingsBtn" class="icon-btn" title="Settings" aria-label="Settings">Settings</button>
        <button id="installBtn" class="icon-btn hidden" title="Install app" aria-label="Install app">Install</button>
      </div>
    </header>

    <!-- META ROW -->
        <section id="meta" class="px-4 text-sm flex-none">

      <div class="flex flex-wrap items-center gap-x-2 gap-y-1 w-full">

        <span class="opacity-70">Field:</span>

        <span id="fieldNameLabel" class="font-semibold">-</span>
        <span class="mx-2 opacity-30">&middot;</span>

        <span class="opacity-70">Started:</span>

        <span id="startedAt" class="font-mono">-</span>
        <span id="viewModeBadge" class="hidden ml-auto text-xs uppercase tracking-wide text-green-600 dark:text-green-400">Viewing</span>

      </div>

    </section>

    <!-- MAIN CONTENT (3 COLUMNS) -->
    <div id="mainContent">
      <!-- LEFT COLUMN -->
      <div class="column">
        <!-- HISTORY -->
        <section id="historyWrap" class="flex flex-col flex-1 overflow-hidden">
          <h2 class="font-semibold mt-1 mb-2 flex-none">History</h2>
          <div id="history" class="flex-1 overflow-y-auto card p-2"></div>

          <!-- History stats: compact single-row numeric badges (Slow / Good / Fast) -->
          <div id="historyStats" class="mt-3 text-sm">
            <div class="flex items-center gap-3">
              <div class="flex items-center gap-2">
                <span id="countSlow" class="stat-badge bg-[color:var(--red)] text-white">0</span>
                <span id="countGood" class="stat-badge bg-[color:var(--green)] text-white">0</span>
                <span id="countFast" class="stat-badge bg-[color:var(--yellow)] text-white">0</span>
              </div>
            </div>
          </div>
        </section>
        <!-- BACK BUTTON -->
        <button id="btnBack" class="btn bg-purple-600 text-white h-16 text-2xl py-3 mt-2 flex-none">BACK</button>
      </div>

      <!-- CENTER COLUMN: VISUALIZATION -->
      <div class="column flex-none vizColumn" style="width: 3rem;">
        <section id="vizWrap" class="flex flex-col flex-1 overflow-hidden">
          <h2 class="font-semibold mt-1 mb-2 flex-none text-xs text-center opacity-70">Field</h2>
          <svg id="fieldViz" class="flex-1 w-full" style="background: var(--card); border: 1px solid var(--cardBorder); border-radius: 1rem;"></svg>
          <div id="vizLegend" class="mt-2 text-xs space-y-1 flex-none">
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #10B981;"></div>
                <span class="opacity-70">Good</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #EF4444;"></div>
                <span class="opacity-70">Slow</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #F59E0B;"></div>
                <span class="opacity-70">Fast</span>
              </div>
          </div>
        </section>
      </div>

      <!-- RIGHT COLUMN -->
      <div class="column">
        <!-- CURRENT ROW -->
        <section id="currentWrap" class="flex flex-col items-center justify-center text-center flex-none mb-2">
          <div class="opacity-70 text-sm">Current Row</div>
          <div id="currentRow" class="text-4xl font-extrabold">1</div>
        </section>

        <!-- PRIMARY BUTTONS -->
        <section id="primaryWrap" class="grid grid-cols-1 gap-3 flex-1 overflow-hidden">
          <button id="btnSlow" class="btn bg-[color:var(--red)] text-white h-full text-4xl py-4">Slow</button>
          <button id="btnGood" class="btn bg-[color:var(--green)] text-white h-full text-4xl py-4">Good</button>
        </section>

        <!-- FAST BUTTON -->
        <button id="btnFast" class="btn bg-[color:var(--yellow)] text-white h-16 text-2xl py-3 mt-3 flex-none">Fast</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS DIALOG -->
  <dialog id="settingsDialog" class="rounded-2xl p-0 w-[28rem] max-w-[95vw]">
    <form id="settingsForm" class="p-5 space-y-4">
      <div class="text-lg font-bold">Settings</div>
      <div class="grid grid-cols-2 gap-4">
      <label class="flex items-center gap-2"><input id="hapticToggle" type="checkbox"
        class="w-5 h-5" /><span>Vibration</span></label>
      <label class="flex items-center gap-2"><input id="beepToggle" type="checkbox"
        class="w-5 h-5" /><span>Beep</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="wakeToggle" type="checkbox"
        class="w-5 h-5" /><span>Keep screen awake</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="darkToggle" type="checkbox"
        class="w-5 h-5" /><span>Dark theme</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="leftHandedToggle" type="checkbox"
        class="w-5 h-5" /><span>Left-handed layout</span></label>
      </div>
      <div class="flex items-center justify-end pt-2">
        <div class="flex items-center gap-2">
          <button type="button" class="icon-btn" onclick="settingsDialog.close()">Cancel</button>
          <button class="icon-btn bg-gray-900 text-white">Save</button>
        </div>
      </div>
      <div class="text-xs opacity-60 mt-2" id="settingsVersionLabel"></div>
    </form>
  </dialog>

  <!-- Field name dialog (opened by clicking the field label) -->
  <dialog id="fieldNameDialog" class="rounded-2xl p-0 w-[22rem] max-w-[95vw]">
    <form id="fieldNameForm" class="p-5 space-y-4">
      <div class="text-lg font-bold">Field Name</div>
      <label class="block">
        <input id="fieldNameDialogInput" class="mt-1 w-full rounded-xl border border-gray-300 p-3 bg-white text-black" placeholder="e.g., West 40 — Block A" />
      </label>
      <div class="flex items-end justify-end gap-2">
        <button type="button" class="icon-btn" onclick="fieldNameDialog.returnValue='cancel'; fieldNameDialog.close()">Cancel</button>
        <button class="icon-btn bg-gray-900 text-white">Save</button>
      </div>
    </form>
  </dialog>

  <!-- New field confirmation dialog -->
  <dialog id="resetConfirmDialog" class="rounded-2xl p-0 w-[24rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div class="text-lg font-bold">Start a new field?</div>
      <div class="flex gap-2 justify-end">
        <button type="button" class="icon-btn" onclick="resetConfirmDialog.close()">Cancel</button>
        <button type="submit" class="icon-btn bg-red-600 text-white" value="confirm">New field</button>
      </div>
    </form>
  </dialog>

  <!-- Change row status dialog -->
  <dialog id="changeRowDialog" class="rounded-2xl p-0 w-[22rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div class="text-lg font-bold">Change Row Status</div>
      <div class="text-sm opacity-70">
        <div class="mb-3">
          <span class="opacity-50">Row:</span>
          <span id="changeRowNumber" class="font-mono font-bold">—</span>
        </div>
        <div>
          <span class="opacity-50">Current:</span>
          <span id="changeRowCurrent" class="font-semibold">—</span>
        </div>
      </div>
      <div class="space-y-2">
        <button type="button" class="icon-btn w-full bg-[color:var(--green)] text-white font-bold" id="changeRowBtnGood">Good</button>
        <button type="button" class="icon-btn w-full bg-[color:var(--red)] text-white font-bold" id="changeRowBtnSlow">Slow</button>
        <button type="button" class="icon-btn w-full bg-[color:var(--yellow)] text-white font-bold" id="changeRowBtnFast">Fast</button>
      </div>
      <div class="flex gap-2 justify-end pt-2">
        <button type="button" class="icon-btn" onclick="changeRowDialog.close()">Cancel</button>
      </div>
    </form>
  </dialog>

  <!-- Saved fields dialog -->
  <dialog id="savedFieldsDialog" class="rounded-2xl p-0 w-[28rem] max-w-[95vw]">
    <div class="p-5 flex flex-col gap-3 h-full max-h-[85vh]">
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-lg font-bold leading-tight">Saved fields</div>
          <p class="text-xs opacity-70">Keep track of multiple fields per day.</p>
        </div>
        <button type="button" class="icon-btn" id="closeSavedFieldsDialogBtn">Close</button>
      </div>
      <button id="saveFieldBtn" class="icon-btn bg-[color:var(--green)] text-white text-sm font-bold">Save current field</button>
      <div id="savedFieldActions" class="hidden">
        <button id="editSavedFieldBtn" class="icon-btn w-full bg-purple-600 text-white font-bold text-sm">Resume editing</button>
      </div>
      <div class="card flex-1 overflow-hidden">
        <div id="savedFieldsList" class="p-3 space-y-2 overflow-y-auto max-h-[50vh]"></div>
      </div>
      <p class="text-[0.75rem] opacity-60">Saved fields stay on this device.</p>
    </div>
  </dialog>

  <!-- Saved field delete confirmation -->
  <dialog id="savedFieldDeleteDialog" class="rounded-2xl p-0 w-[24rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div class="text-lg font-bold">Remove saved field?</div>
      <p class="text-sm opacity-70">This will permanently remove <span id="savedFieldDeleteLabel" class="font-semibold">this field</span> from this device.</p>
      <div class="flex gap-2 justify-end">
        <button type="button" class="icon-btn" onclick="savedFieldDeleteDialog.close()">Cancel</button>
        <button type="submit" class="icon-btn bg-red-600 text-white" value="confirm">Remove</button>
      </div>
    </form>
  </dialog>

  <!-- Toast (non-blocking) -->
  <div id="toast" role="status" aria-live="polite">Copied to clipboard</div>

  <script>
    const STORAGE_KEY = 'tubetally.v1';
    const SAVED_FIELDS_KEY = 'tubetally.savedFields.v1';
    const MAX_SAVED_FIELDS = 50;
    const $ = s => document.querySelector(s);
    
    // Status mapping: internal codes (color names) map to display labels
    const STATUS_MAP = { 'green': 'Good', 'red': 'Slow', 'yellow': 'Fast' };
    
    const nowLocalISO = () => { const d = new Date(); const p = n => String(n).padStart(2, '0'); return `${d.getFullYear()}-${p(d.getMonth() + 1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}` };

    // ---------- Audio ----------
    let audioCtx = null;
    function ensureAudio() { if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch { } } if (audioCtx?.state === 'suspended') { audioCtx.resume?.(); } }
    function beep(freq = 440, dur = 90) { if (!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination); g.gain.setValueAtTime(0.06, audioCtx.currentTime); o.start(); setTimeout(() => { o.stop(); }, dur); }

    // ---------- Haptic ----------
    function vib(pattern) { if (!state.prefs.haptic) return; if (navigator.vibrate) navigator.vibrate(pattern); }
    const hapticPattern = { 'Good': [20, 40, 20], 'Slow': [80], 'Fast': [40, 30, 40], 'UNDO': [30, 20, 30] };

    // ---------- Wake Lock ----------
    let wakeLock = null; async function updateWakeLock() { try { if (state.prefs.wake) { wakeLock = await navigator.wakeLock?.request('screen'); wakeLock?.addEventListener?.('release', () => { }); } else { await wakeLock?.release?.(); wakeLock = null; } } catch { } }
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') updateWakeLock(); });

    // ---------- State ----------
    const initial = { fieldName: '', startedAt: '', currentRow: 1, rows: {}, actions: [], prefs: { haptic: true, beep: true, wake: true, dark: false, leftHanded: false } };
    let state = load();
    let viewMode = false; // true = view-only shared mode, false = normal edit mode
    let viewModeSource = null; // 'share' | 'savedField' | null
    let viewingSavedFieldId = null;
    let savedFieldReturnState = null;
    let savedFieldReturnMeta = null;
    let currentlyEditingSavedFieldId = null;
    let savedFields = loadSavedFields();
    let savedFieldsDialog = null;
    let savedFieldDeleteDialog = null;
    let pendingDeleteSavedFieldId = null;
    let pendingFieldNameAction = null;
    let fieldNameDialog = null;
    let fieldNameInputDialog = null;
    function load() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || { ...initial, startedAt: nowLocalISO() }; } catch { return { ...initial, startedAt: nowLocalISO() }; } }
    function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

    // ---------- Saved fields storage ----------
    function loadSavedFields() { try { return JSON.parse(localStorage.getItem(SAVED_FIELDS_KEY)) || []; } catch { return []; } }
    function persistSavedFields() { try { localStorage.setItem(SAVED_FIELDS_KEY, JSON.stringify(savedFields)); } catch { } }

    // ---------- Layout calculation ----------
    function layout() {
      // Layout is now handled by flexbox, no complex calculations needed
    }
    window.addEventListener('resize', layout);
    window.addEventListener('orientationchange', () => setTimeout(layout, 200));

    // ---------- Render ----------
    function render(shouldScrollToBottom = false) {
      document.documentElement.classList.toggle('dark', !!state.prefs.dark);
      document.getElementById('app').classList.toggle('flip-layout', !!state.prefs.leftHanded);
      $('#currentRow').textContent = state.currentRow;
      $('#fieldNameLabel').textContent = state.fieldName || '-';
      $('#startedAt').textContent = state.startedAt || '-';
      renderSavedFieldsList();
      const badge = $('#viewModeBadge');
      if (badge) {
        if (viewMode) {
          badge.classList.remove('hidden');
          badge.textContent = viewModeSource === 'savedField' ? 'Viewing saved field' : 'View only';
        } else {
          badge.classList.add('hidden');
        }
      }
      const editSavedFieldActions = document.getElementById('savedFieldActions');
      const canResumeSavedField = viewMode && viewModeSource === 'savedField';
      if (editSavedFieldActions) editSavedFieldActions.classList.toggle('hidden', !canResumeSavedField);
      const counts = { green: 0, red: 0, yellow: 0 };
      const h = $('#history');
      const scrollPos = h.scrollTop;
      h.innerHTML = '';
      const keys = Object.keys(state.rows).map(Number).sort((a, b) => a - b);
      for (const n of keys) {
        const st = state.rows[n];
        const stLabel = STATUS_MAP[st] || st;
        if (counts[st] !== undefined) counts[st]++;
        const c = st === 'green' ? 'bg-[color:var(--green)]' : st === 'red' ? 'bg-[color:var(--red)]' : 'bg-[color:var(--yellow)]';
        const d = document.createElement('div');
        d.className = 'border-b' + (document.documentElement.classList.contains('dark') ? ' border-gray-700' : ' border-gray-200') + ' py-2' + (viewMode ? '' : ' cursor-pointer hover:opacity-80 transition-opacity');
        d.style.userSelect = 'none';
        // pad number to 3 digits (non-breaking spaces) and right-align, make badge non-wrapping
        const num = String(n).padStart(3, '\u00A0');
        d.innerHTML = `<div class='history-row w-full'><span class='history-number font-mono opacity-70'>${num}:</span><span class='history-badge text-white ${c}'>${stLabel}</span></div>`;
        if (!viewMode) {
          d.addEventListener('click', () => openChangeRowDialog(n, st));
        }
        h.appendChild(d);
      }
      
      if (shouldScrollToBottom) {
        h.scrollTop = h.scrollHeight;
      } else {
        h.scrollTop = scrollPos;
      }

      // update the small stats under the history
      const elSlow = document.getElementById('countSlow');
      const elGood = document.getElementById('countGood');
      const elFast = document.getElementById('countFast');
      if (elSlow) elSlow.textContent = String(counts['red'] || 0).padStart(3, '\u00A0');
      if (elGood) elGood.textContent = String(counts['green'] || 0).padStart(3, '\u00A0');
      if (elFast) elFast.textContent = String(counts['yellow'] || 0).padStart(3, '\u00A0');

      // Render field visualization
      renderFieldViz();

      // Update visibility based on view mode
      updateViewMode();

      layout();
    }

    function summarizeRows(rows = {}) {
      const totals = { green: 0, red: 0, yellow: 0 };
      if (!rows) return totals;
      for (const status of Object.values(rows)) {
        if (totals[status] !== undefined) totals[status]++;
      }
      return totals;
    }

    function renderSavedFieldsList() {
      const list = document.getElementById('savedFieldsList');
      if (!list) return;
      list.innerHTML = '';
      if (!savedFields.length) {
        const empty = document.createElement('div');
        empty.className = 'saved-field-empty';
        empty.textContent = 'No saved fields yet';
        list.appendChild(empty);
        return;
      }
      const activeId = viewMode && viewModeSource === 'savedField' ? viewingSavedFieldId : null;
      const editingId = currentlyEditingSavedFieldId;
      for (const field of savedFields) {
        const counts = summarizeRows(field.rows);
        const item = document.createElement('div');
        item.className = 'saved-field-item';
        if (activeId === field.id || editingId === field.id) item.classList.add('active');
        item.dataset.id = field.id;
        const savedText = field.savedAt ? `Saved ${field.savedAt}` : 'Saved field';
        const statusLabel = activeId === field.id ? 'Viewing' : editingId === field.id ? 'Editing' : savedText;
        item.innerHTML = `
          <div class="flex items-start justify-between gap-2">
            <div>
              <div class="font-semibold leading-tight">${field.fieldName || 'Untitled field'}</div>
              <div class="text-xs opacity-70">${field.startedAt || '-'}</div>
            </div>
            <button type="button" class="text-xs font-semibold text-red-500 opacity-70 hover:opacity-100" data-action="delete" data-id="${field.id}">Remove</button>
          </div>
          <div class="flex gap-2 text-xs font-mono mt-2">
            <span class="stat-badge bg-[color:var(--green)] text-white">G ${String(counts.green || 0).padStart(3, '\u00A0')}</span>
            <span class="stat-badge bg-[color:var(--yellow)] text-white">F ${String(counts.yellow || 0).padStart(3, '\u00A0')}</span>
            <span class="stat-badge bg-[color:var(--red)] text-white">S ${String(counts.red || 0).padStart(3, '\u00A0')}</span>
          </div>
          <div class="text-[0.7rem] opacity-60 mt-1">${statusLabel}</div>
        `;
        list.appendChild(item);
      }
    }

    // ---------- View Mode ----------
    function updateViewMode() {
      const rightCol = document.querySelector('#mainContent > .column:last-child');
      const vizCol = document.querySelector('.vizColumn');
      const centerCol = document.querySelector('#mainContent > .column:nth-child(2)');
      const historyStats = document.getElementById('historyStats');
      const vizLegend = document.getElementById('vizLegend');
      const backBtn = $('#btnBack');
      const saveFieldBtn = $('#saveFieldBtn');
      const hasRows = Object.keys(state.rows || {}).length > 0;
      if (saveFieldBtn) {
        saveFieldBtn.disabled = viewMode || !hasRows;
        saveFieldBtn.title = viewMode ? 'Exit view mode to save new fields' : (!hasRows ? 'Record at least one row to enable saving' : 'Save this field and reset for the next one');
      }
      
      if (viewMode) {
        // Hide edit controls, show visualization
        rightCol.style.display = 'none'; // Hide entire right column
        centerCol.style.display = ''; // Show visualization
        vizCol.style.width = '30%'; // Make visualization 30% width
        centerCol.style.flex = 'none'; // Reset flex
        historyStats.style.display = 'none';
        if (vizLegend) vizLegend.style.display = '';
        document.getElementById('resetBtn').style.display = 'none';
        document.getElementById('settingsBtn').style.display = 'none';
        document.getElementById('installBtn').style.display = 'none';
        backBtn.textContent = viewModeSource === 'savedField' ? 'EXIT VIEW' : 'EDIT';
        backBtn.onclick = () => toggleViewMode(); // Change handler to toggle view mode
        // Re-render to account for new width
        setTimeout(() => renderFieldViz(), 0);
      } else {
        // Show all controls
        rightCol.style.display = ''; // Show entire right column
        centerCol.style.display = '';
        vizCol.style.width = '3rem'; // Reset to thin width
        centerCol.style.flex = ''; // Reset flex
        historyStats.style.display = '';
        if (vizLegend) vizLegend.style.display = 'none';
        document.getElementById('resetBtn').style.display = '';
        document.getElementById('settingsBtn').style.display = '';
        backBtn.textContent = 'BACK'; // Change button text back to BACK
        backBtn.onclick = () => undo(); // Change handler back to undo
        // Re-render to account for new width
        setTimeout(() => renderFieldViz(), 0);
      }
    }

    function toggleViewMode() {
      if (!viewMode) return;
      if (viewModeSource === 'savedField') {
        currentlyEditingSavedFieldId = viewingSavedFieldId;
        savedFieldReturnState = null;
        savedFieldReturnMeta = null;
        viewingSavedFieldId = null;
        viewModeSource = null;
        viewMode = false;
        save();
        render();
        showToast('Editing field');
        return;
      }
      if (savedFieldReturnState) {
        state = savedFieldReturnState;
        savedFieldReturnState = null;
        currentlyEditingSavedFieldId = savedFieldReturnMeta?.editingId || null;
        savedFieldReturnMeta = null;
        viewingSavedFieldId = null;
        viewModeSource = null;
        viewMode = false;
        save();
        render();
        return;
      }
      savedFieldReturnState = null;
      savedFieldReturnMeta = null;
      viewingSavedFieldId = null;
      viewModeSource = null;
      viewMode = false;
      render();
    }

    // ---------- Saved Fields ----------
    function nextRowFromRows(rows = {}) {
      const keys = Object.keys(rows || {}).map(k => parseInt(k, 10)).filter(n => !isNaN(n));
      if (!keys.length) return 1;
      return Math.max(...keys) + 1;
    }

    function saveCurrentField() {
      if (viewMode) {
        showToast('Exit view mode to save fields');
        return;
      }
      const hasRows = Object.keys(state.rows || {}).length;
      if (!hasRows) {
        showToast('No rows recorded yet');
        return;
      }
      if (!state.fieldName) {
        pendingFieldNameAction = 'saveField';
        if (fieldNameInputDialog) {
          fieldNameInputDialog.value = state.fieldName || '';
          setTimeout(() => fieldNameInputDialog?.focus(), 0);
        }
        fieldNameDialog?.showModal();
        return;
      }
      const editingId = currentlyEditingSavedFieldId;
      const snapshot = {
        id: editingId || `${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
        fieldName: state.fieldName || `Field ${savedFields.length + 1}`,
        startedAt: state.startedAt || nowLocalISO(),
        savedAt: nowLocalISO(),
        rows: { ...state.rows },
        currentRow: state.currentRow
      };
      savedFields = savedFields.filter(f => f.id !== snapshot.id);
      savedFields.unshift(snapshot);
      if (savedFields.length > MAX_SAVED_FIELDS) savedFields = savedFields.slice(0, MAX_SAVED_FIELDS);
      persistSavedFields();
      renderSavedFieldsList();
      showToast(editingId ? 'Field updated' : 'Field saved');
      currentlyEditingSavedFieldId = null;
      resetNow();
    }

    function deleteSavedField(id) {
      const idx = savedFields.findIndex(f => f.id === id);
      if (idx === -1) return;
      const removed = savedFields[idx];
      savedFields.splice(idx, 1);
      persistSavedFields();
      if (viewMode && viewModeSource === 'savedField' && viewingSavedFieldId === id) {
        toggleViewMode();
      } else {
        renderSavedFieldsList();
      }
      showToast('Field removed');
      return removed;
    }

    function requestDeleteSavedField(id) {
      const entry = savedFields.find(f => f.id === id);
      if (!entry || !savedFieldDeleteDialog) return;
      pendingDeleteSavedFieldId = id;
      const label = entry.fieldName || 'this field';
      const labelEl = document.getElementById('savedFieldDeleteLabel');
      if (labelEl) labelEl.textContent = label;
      savedFieldDeleteDialog.showModal();
    }

    function viewSavedField(id) {
      if (!id) return;
      if (viewMode && viewModeSource === 'savedField' && viewingSavedFieldId === id) return;
      const entry = savedFields.find(f => f.id === id);
      if (!entry) return;
      if (viewModeSource !== 'savedField' || !savedFieldReturnState) {
        savedFieldReturnState = state;
        savedFieldReturnMeta = { editingId: currentlyEditingSavedFieldId };
      }
      currentlyEditingSavedFieldId = null;
      const prefsSource = savedFieldReturnState ? savedFieldReturnState.prefs : state.prefs;
      state = {
        ...initial,
        fieldName: entry.fieldName || '',
        startedAt: entry.startedAt || '',
        rows: { ...entry.rows },
        actions: [],
        currentRow: entry.currentRow || nextRowFromRows(entry.rows),
        prefs: { ...prefsSource }
      };
      viewMode = true;
      viewModeSource = 'savedField';
      viewingSavedFieldId = entry.id;
      if (savedFieldsDialog?.open) savedFieldsDialog.close();
      render(true);
      showToast(`Viewing ${entry.fieldName || 'saved field'}`);
    }

    function beginEditingSavedField() {
      if (!(viewMode && viewModeSource === 'savedField' && viewingSavedFieldId)) return;
      const entry = savedFields.find(f => f.id === viewingSavedFieldId);
      if (!entry) return;
      const label = entry.fieldName || 'this field';
      if (!window.confirm(`Resume editing "${label}"? This will replace your current active field.`)) return;
      currentlyEditingSavedFieldId = entry.id;
      savedFieldReturnState = null;
      savedFieldReturnMeta = null;
      viewMode = false;
      viewModeSource = null;
      viewingSavedFieldId = null;
      save();
      render();
      showToast('Editing field');
      if (savedFieldsDialog?.open) savedFieldsDialog.close();
    }

    // ---------- Field Visualization ----------
    function renderFieldViz() {
      const svg = $('#fieldViz');
      if (!svg) return;
      
      const svgRect = svg.getBoundingClientRect();
      const width = svgRect.width || 48;
      const height = svgRect.height || 400;
      
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.innerHTML = '';
      
      const keys = Object.keys(state.rows).map(Number).sort((a, b) => a - b);
      const totalRows = Math.max(state.currentRow - 1, 50); // Assume minimum 50 rows
      const rowHeight = height / totalRows;
      
      // Draw each logged row as a colored band
      for (const rowNum of keys) {
        const status = state.rows[rowNum];
        const color = status === 'green' ? '#10B981' : status === 'red' ? '#EF4444' : '#F59E0B';
        
        const y = (rowNum - 1) * rowHeight;
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', rowHeight);
        rect.setAttribute('fill', color);
        rect.style.opacity = '0.85';
        svg.appendChild(rect);
      }
      
      // Draw a line at the current row position
      const currentY = (state.currentRow - 1) * rowHeight;
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', '0');
      line.setAttribute('y1', currentY);
      line.setAttribute('x2', width);
      line.setAttribute('y2', currentY);
      line.setAttribute('stroke', '#6B7280');
      line.setAttribute('stroke-width', '2');
      line.style.opacity = '0.5';
      svg.appendChild(line);
    }

    // ---------- Actions ----------
    function record(status) {
      if (viewMode) {
        showToast('Viewing saved field');
        return;
      }
      ensureAudio();
      const label = STATUS_MAP[status] || status;
      if (state.prefs.haptic) vib(hapticPattern[label]);
      if (state.prefs.beep && audioCtx) beep(status === 'green' ? 700 : status === 'red' ? 300 : 520, 100);
      state.rows[state.currentRow] = status;
      state.actions.push(state.currentRow);
      state.currentRow++;
      save();
      render(true);
    }
    function undo() {
      if (viewMode) {
        toggleViewMode();
        return;
      }
      ensureAudio();
      const last = state.actions.pop();
      if (!last) return;
      if (state.prefs.haptic) vib(hapticPattern.UNDO);
      if (state.prefs.beep && audioCtx) beep(250, 110);
      delete state.rows[last];
      state.currentRow = last;
      save();
      render(true);
    }

    // Long-press to test tone/haptic without recording
    function addHoldTest(el, status) {
      let t = null; el.addEventListener('pointerdown', () => { t = setTimeout(() => { ensureAudio(); const label = STATUS_MAP[status] || status; if (state.prefs.haptic) vib(hapticPattern[label]); if (state.prefs.beep && audioCtx) beep(status === 'green' ? 700 : status === 'red' ? 300 : 520, 200); t = null; }, 550); }, { passive: true });
      ['pointerup', 'pointercancel', 'pointerleave'].forEach(ev => el.addEventListener(ev, () => { if (t) { clearTimeout(t); t = null; } }, { passive: true }));
    }

    // ---------- Report ----------
    function buildReport() {
      const b = { 'green': [], 'yellow': [], 'red': [] };
      for (const [k, v] of Object.entries(state.rows)) if (b[v]) b[v].push(+k);
      for (const k in b) b[k].sort((a, b) => a - b);
      const cG = b['green'].length, cF = b['yellow'].length, cS = b['red'].length;
      const header = `Field: ${state.fieldName || '—'}\nDate: ${nowLocalISO()}`;
      const body = [`Good (${cG} rows): ${b['green'].join(', ')}`, '', `Fast (${cF} rows): ${b['yellow'].join(', ')}`, '', `Slow (${cS} rows): ${b['red'].join(', ')}`].join('\n');
      return `${header}\n\n${body}`;
    }

    function compressData(rows) {
      // Convert rows object to compact string: "1:G,2:R,3:Y" format (green/red/yellow)
      const parts = [];
      for (let i = 1; i < state.currentRow; i++) {
        if (rows[i]) {
          const status = rows[i];
          const char = status === 'green' ? 'G' : status === 'red' ? 'R' : 'Y';
          parts.push(`${i}:${char}`);
        }
      }
      return parts.join(',');
    }

    function decompressData(compressed) {
      const rows = {};
      if (!compressed) return rows;
      const parts = compressed.split(',');
      for (const part of parts) {
        const [rowStr, char] = part.split(':');
        const rowNum = parseInt(rowStr, 10);
        const status = char === 'G' ? 'green' : char === 'R' ? 'red' : 'yellow';
        rows[rowNum] = status;
      }
      return rows;
    }

    function buildShareUrl() {
      // Compress data: field name and compressed rows
      const compressed = compressData(state.rows);
      const data = `${state.fieldName || 'Field'}|${state.startedAt || ''}|${compressed}`;
      const encoded = btoa(data).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      // Generate full URL with hash, works for both file:// and http(s)://
      const currentUrl = window.location.href.split('#')[0]; // Remove any existing hash
      return `${currentUrl}#d=${encoded}`;
    }

    function loadFromShareUrl() {
      const fullHash = window.location.hash;
      console.log('Full hash:', fullHash);
      if (!fullHash || !fullHash.includes('d=')) return false;
      
      try {
        // Extract the hash portion after #
        let encoded = fullHash.substring(fullHash.indexOf('d=') + 2);
        console.log('Encoded:', encoded);
        
        // Restore padding for base64
        encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');
        // Add padding as needed
        while (encoded.length % 4) encoded += '=';
        console.log('After padding:', encoded);
        
        const data = atob(encoded);
        console.log('Decoded data:', data);
        
        const parts = data.split('|');
        const fieldName = parts[0];
        const startedAt = parts[1];
        const compressed = parts[2];
        
        console.log('Parsed:', { fieldName, startedAt, compressed });
        
        if (fieldName !== undefined) {
          state.fieldName = fieldName === 'Field' ? '' : fieldName;
          state.startedAt = startedAt || nowLocalISO();
          state.rows = decompressData(compressed);
          state.currentRow = Math.max(...Object.keys(state.rows).map(Number), 0) + 1 || 1;
          console.log('Loaded state:', state);
          viewMode = true; // Enable view mode for shared URLs
          viewModeSource = 'share';
          viewingSavedFieldId = null;
          currentlyEditingSavedFieldId = null;
          savedFieldReturnState = null;
          savedFieldReturnMeta = null;
          save();
          return true;
        }
      } catch (err) {
        console.error('Failed to load from share URL:', err);
      }
      return false;
    }

    // Share: native sheet when available; else copy silently with toast (no blocking prompts)
    async function shareReport() { 
      const url = buildShareUrl();
      const text = buildReport() + '\n\n' + url;
      if (navigator.share) { 
        try { 
          await navigator.share({ title: 'TubeTally Report', text }); 
          return; 
        } catch { return; } 
      } 
      try { 
        await navigator.clipboard.writeText(text); 
        showToast('Copied to clipboard'); 
      } catch { /* ignore */ } 
    }

    function showToast(msg) { const el = $('#toast'); el.textContent = msg; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 1500); }

    // Reset: clears field-name/rows/status and storage; preserves preferences
    function resetNow() {
      const prefsCopy = { ...state.prefs };
      viewMode = false;
      viewModeSource = null;
      viewingSavedFieldId = null;
      savedFieldReturnState = null;
      savedFieldReturnMeta = null;
      currentlyEditingSavedFieldId = null;
      state = { ...initial, fieldName: '', startedAt: nowLocalISO(), prefs: prefsCopy, rows: {}, actions: [] };
      try { localStorage.removeItem(STORAGE_KEY); } catch { }
      save();
      render();
    }

    // ---------- Change Row Dialog ----------
    let changeRowDialogData = { rowNum: null, oldStatus: null };
    function openChangeRowDialog(rowNum, currentStatus) {
      changeRowDialogData = { rowNum, oldStatus: currentStatus };
      $('#changeRowNumber').textContent = rowNum;
      $('#changeRowCurrent').textContent = (STATUS_MAP[currentStatus] || currentStatus);
      document.getElementById('changeRowDialog').showModal();
    }
    function changeRowStatus(newStatus) {
      if (viewMode) return;
      if (changeRowDialogData.rowNum === null) return;
      state.rows[changeRowDialogData.rowNum] = newStatus;
      save();
      render(false);
      document.getElementById('changeRowDialog').close();
    }

    // ---------- Bindings ----------
    $('#btnGood').onclick = () => record('green');
    $('#btnSlow').onclick = () => record('red');
    $('#btnFast').onclick = () => record('yellow');
    $('#btnBack').onclick = () => undo();
    addHoldTest($('#btnGood'), 'green');
    addHoldTest($('#btnSlow'), 'red');
    addHoldTest($('#btnFast'), 'yellow');

    const saveFieldBtnEl = document.getElementById('saveFieldBtn');
    if (saveFieldBtnEl) saveFieldBtnEl.addEventListener('click', () => { ensureAudio(); saveCurrentField(); });
    const editSavedFieldBtnEl = document.getElementById('editSavedFieldBtn');
    if (editSavedFieldBtnEl) editSavedFieldBtnEl.addEventListener('click', () => { ensureAudio(); beginEditingSavedField(); });
    const savedFieldsListEl = document.getElementById('savedFieldsList');
    if (savedFieldsListEl) {
      savedFieldsListEl.addEventListener('click', (event) => {
        const deleteBtn = event.target.closest('[data-action="delete"]');
        if (deleteBtn) {
          event.stopPropagation();
          requestDeleteSavedField(deleteBtn.dataset.id);
          return;
        }
        const item = event.target.closest('.saved-field-item');
        if (item) {
          ensureAudio();
          viewSavedField(item.dataset.id);
        }
      });
    }

    // Change row status dialog handlers
    document.getElementById('changeRowBtnGood').onclick = () => changeRowStatus('green');
    document.getElementById('changeRowBtnSlow').onclick = () => changeRowStatus('red');
    document.getElementById('changeRowBtnFast').onclick = () => changeRowStatus('yellow');

    $('#shareBtn').onclick = () => { ensureAudio(); shareReport(); };
    
    savedFieldsDialog = document.getElementById('savedFieldsDialog');
    if (savedFieldsDialog) {
      const savedFieldsBtn = document.getElementById('savedFieldsBtn');
      if (savedFieldsBtn) savedFieldsBtn.addEventListener('click', () => {
        ensureAudio();
        renderSavedFieldsList();
        savedFieldsDialog.showModal();
      });
      const closeSavedFieldsDialogBtn = document.getElementById('closeSavedFieldsDialogBtn');
      if (closeSavedFieldsDialogBtn) closeSavedFieldsDialogBtn.addEventListener('click', () => savedFieldsDialog.close());
    }
    
    savedFieldDeleteDialog = document.getElementById('savedFieldDeleteDialog');
    if (savedFieldDeleteDialog) {
      window.savedFieldDeleteDialog = savedFieldDeleteDialog;
      savedFieldDeleteDialog.addEventListener('close', () => {
        if (savedFieldDeleteDialog.returnValue === 'confirm' && pendingDeleteSavedFieldId) {
          deleteSavedField(pendingDeleteSavedFieldId);
        }
        pendingDeleteSavedFieldId = null;
      });
    }
    
    // Reset button: show confirmation dialog instead of immediately resetting
    const resetConfirmDialog = document.getElementById('resetConfirmDialog');
    $('#resetBtn').onclick = () => {
      resetConfirmDialog.showModal();
    };
    resetConfirmDialog.addEventListener('close', (e) => {
      if (resetConfirmDialog.returnValue === 'confirm') {
        resetNow();
        showToast('New field started');
      }
    });

    // Settings dialog
    const settingsDialog = document.getElementById('settingsDialog');
    $('#settingsBtn').onclick = () => {
      $('#hapticToggle').checked = !!state.prefs.haptic;
      $('#beepToggle').checked = !!state.prefs.beep;
      $('#wakeToggle').checked = !!state.prefs.wake;
      $('#darkToggle').checked = !!state.prefs.dark;
      $('#leftHandedToggle').checked = !!state.prefs.leftHanded;
      settingsDialog.showModal();
    };
    document.getElementById('settingsForm').addEventListener('submit', (e) => {
      e.preventDefault();
      state.prefs.haptic = $('#hapticToggle').checked;
      state.prefs.beep = $('#beepToggle').checked;
      state.prefs.wake = $('#wakeToggle').checked;
      state.prefs.dark = $('#darkToggle').checked;
      state.prefs.leftHanded = $('#leftHandedToggle').checked;
      if (!state.startedAt) state.startedAt = nowLocalISO();
      save(); render(); settingsDialog.close(); updateWakeLock();
    });

    // Field name dialog bindings (opened by clicking the field label)
    fieldNameDialog = document.getElementById('fieldNameDialog');
    if (fieldNameDialog?.open) fieldNameDialog.close();
    // also expose on window so inline onclick="fieldNameDialog.close()" works
    window.fieldNameDialog = fieldNameDialog;
    fieldNameInputDialog = document.getElementById('fieldNameDialogInput');
    document.getElementById('fieldNameLabel').addEventListener('click', () => {
      if (viewMode) return;
      fieldNameInputDialog.value = state.fieldName || '';
      fieldNameDialog.showModal();
    });
    document.getElementById('fieldNameForm').addEventListener('submit', (e) => {
      e.preventDefault();
      state.fieldName = fieldNameInputDialog.value.trim();
      if (!state.startedAt) state.startedAt = nowLocalISO();
      save();
      render();
      const pendingAction = pendingFieldNameAction;
      pendingFieldNameAction = null;
      fieldNameDialog.returnValue = 'submit';
      fieldNameDialog.close();
      if (pendingAction === 'saveField' && state.fieldName) {
        setTimeout(() => saveCurrentField(), 0);
      }
    });
    if (fieldNameDialog) {
      fieldNameDialog.addEventListener('close', () => {
        if (fieldNameDialog.returnValue !== 'submit') {
          pendingFieldNameAction = null;
        }
        fieldNameDialog.returnValue = '';
      });
    }

    // Prime audio on first interaction
    document.addEventListener('touchstart', ensureAudio, { once: true });
    document.addEventListener('mousedown', ensureAudio, { once: true });

    const isShared = loadFromShareUrl();
    render(isShared);
    if (isShared) {
      // Delay toast slightly to ensure DOM is ready
      setTimeout(() => showToast('Report loaded from URL'), 100);
    }
    updateWakeLock();

    // load version from single source (src/version.json)
    (async function loadVersion(){
      try {
        // Always bypass caches when checking version.json
        const res = await fetch('./version.json', {cache: 'no-store'});
        if (!res.ok) return;
        const data = await res.json();
        const ver = data.version || '';
        const appVerEl = document.getElementById('appVersionLabel');
        const settingsVerEl = document.getElementById('settingsVersionLabel');
        if (appVerEl) appVerEl.textContent = ver;
        if (settingsVerEl) settingsVerEl.textContent = ver;

        // If the version changed since last load, perform a single cache-busting reload.
        // This avoids requiring users to use DevTools -> Empty Cache and Hard Reload.
        try {
          const last = localStorage.getItem('tubetally.cachedVersion') || '';
          if (last !== ver) {
            // store new version
            localStorage.setItem('tubetally.cachedVersion', ver);
            // Only trigger a reload once per session to avoid loops
            const sessionKey = 'tubetally.reloadedFor';
            const already = sessionStorage.getItem(sessionKey);
            if (already !== ver) {
              sessionStorage.setItem(sessionKey, ver);
              // Build a cache-busting URL (preserve hash)
              const base = window.location.href.split('#')[0].split('?')[0];
              const hash = window.location.hash || '';
              const cbUrl = `${base}?cb=${Date.now()}${hash}`;
              // Use replace to avoid creating history entries
              window.location.replace(cbUrl);
            }
          }
        } catch (e) {
          console.warn('version reload check failed', e);
        }

      } catch (err) {
        console.warn('Failed to load version.json', err);
      }
    })();
    
    // Scroll history to bottom on page load
    setTimeout(() => {
      const h = $('#history');
      if (h) h.scrollTop = h.scrollHeight;
    }, 0);
  </script>
  <script>
    // Register service worker for offline support and installability
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js').then(() => {
        console.log('Service worker registered');
      }).catch((err) => {
        console.warn('Service worker registration failed:', err);
      });
    }

    // Optional: capture install prompt for custom UI and wire the Install button
    window.deferredPrompt = null;
    const installBtnEl = document.getElementById('installBtn');
    if (installBtnEl) {
      installBtnEl.addEventListener('click', async () => {
        if (!window.deferredPrompt) return;
        window.deferredPrompt.prompt();
        try {
          const choice = await window.deferredPrompt.userChoice;
          if (choice.outcome === 'accepted') showToast('App installed'); else showToast('Install dismissed');
        } catch (err) {
          console.warn('install prompt error', err);
        }
        window.deferredPrompt = null;
        installBtnEl.classList.add('hidden');
      });
    }

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      window.deferredPrompt = e;
      if (installBtnEl) installBtnEl.classList.remove('hidden');
      console.log('beforeinstallprompt captured');
    });

    window.addEventListener('appinstalled', (e) => {
      window.deferredPrompt = null;
      if (installBtnEl) installBtnEl.classList.add('hidden');
      showToast('App installed');
    });
  </script>
</body>

</html>
