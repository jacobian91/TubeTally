<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>TubeTally — Irrigation Row Counter</title>
  <meta name="theme-color" content="#10B981" />
  <link rel="manifest" href="./manifest.json" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="TubeTally">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="format-detection" content="telephone=no">
  <link rel="apple-touch-icon" sizes="180x180" href="./icon-180.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --purple: #9333EA;
      --green: #10B981;
      --red: #EF4444;
      --yellow: #F59E0B;
      --bg: #ffffff;
      --fg: #111827;
      --card: #ffffff;
      --cardBorder: #e5e7eb;
    }

    .dark {
      --bg: #0b0b0c;
      --fg: #e5e7eb;
      --card: #141417;
      --cardBorder: #26272b;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      touch-action: manipulation;
      -ms-touch-action: manipulation;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100svh;
      padding-bottom: env(safe-area-inset-bottom);
    }

    #mainContent {
      display: flex;
      flex: 1;
      overflow: hidden;
      gap: 1rem;
      padding: 0 1rem 1rem 1rem;
    }

    .column {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }

    #app.flip-layout #mainContent {
      flex-direction: row-reverse;
    }

    .btn {
      border-radius: 1rem;
      font-weight: 800;
      box-shadow: 0 6px 14px rgba(0, 0, 0, .08);
      transition: transform .05s;
    }

    .btn:active {
      transform: scale(.98);
    }

    .icon-btn {
      border-radius: .75rem;
      padding: .5rem .75rem;
      display: flex;
      align-items: center;
      gap: .5rem;
    }
    .icon-btn[data-surface] {
      background: #f3f4f6;
      color: #111827;
    }
    .dark .icon-btn[data-surface] {
      background: #1f2937;
      color: #f3f4f6;
    }
    .icon-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .icon-btn.bg-transparent {
      background: rgba(0, 0, 0, 0.04);
    }
    .dark .icon-btn.bg-transparent {
      background: rgba(255, 255, 255, 0.08);
      color: inherit;
    }
    .action-btn {
      font-weight: 700;
      color: #fff;
    }
    .action-load {
      background: rgba(59, 130, 246, 0.85);
    }
    .dark .action-load {
      background: rgba(96, 165, 250, 0.9);
    }
    .action-share {
      background: var(--purple);
    }
    .dark .action-share {
      background: var(--purple);
    }
    .action-remove {
      background: var(--red);
    }
    .dark .action-remove {
      background: var(--red);
    }

    .card {
      border: 1px solid var(--cardBorder);
      background: var(--card);
      border-radius: 1rem;
    }

    /* History row styles: fixed-width right-aligned numbers and non-wrapping status badges */
    .history-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .history-number {
      width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Segoe UI Mono', monospace;
    }

    .history-badge {
      display: inline-block;
      white-space: nowrap;
      padding: .25rem .6rem;
      font-weight: 700;
      border-radius: .5rem;
      font-size: .95rem;
    }

    /* Compact stat badges shown under history: 3-digit padded numbers */
    .stat-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 3ch;
      padding: .12rem .4rem;
      border-radius: .5rem;
      font-weight: 800;
      font-size: .95rem;
      white-space: nowrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Segoe UI Mono', monospace;
    }
    .saved-field-item {
      border: 1px solid var(--cardBorder);
      background: var(--card);
      border-radius: 0.9rem;
      padding: 0.75rem 0.95rem 0.85rem;
      cursor: pointer;
      transition: border-color .15s, box-shadow .15s, transform .08s;
    }
    .saved-field-item:hover {
      border-color: rgba(16, 185, 129, 0.6);
    }
    .saved-field-item:active {
      transform: scale(.99);
    }
    .saved-field-item.active {
      border-color: var(--green);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
    }
    .saved-field-header {
      display: flex;
      flex-wrap: nowrap;
      align-items: flex-start;
      gap: 0.5rem;
    }
    .saved-field-meta {
      flex: 1;
      min-width: 12rem;
    }
    .saved-field-actions {
      display: flex;
      flex-wrap: nowrap;
      justify-content: flex-end;
      gap: 0.5rem;
    }
    .saved-field-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .saved-field-row .saved-field-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .saved-field-secondary-actions {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.5rem;
      margin-left: auto;
    }
    .saved-field-empty {
      border: 1px dashed var(--cardBorder);
      border-radius: 0.9rem;
      padding: 1rem;
      text-align: center;
      font-size: .85rem;
      opacity: .7;
    }
    #saveFieldBtn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    #viewModeBadge {
      background: rgba(107, 114, 128, 0.18);
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-weight: 700;
      font-size: .75rem;
    }
    dialog {
      border: none;
      color: var(--fg);
    }
    dialog form,
    dialog > div {
      background: var(--card);
      color: var(--fg);
    }

    #toast {
      position: fixed;
      left: 50%;
      bottom: calc(env(safe-area-inset-bottom) + 12px);
      transform: translateX(-50%);
      background: #111827;
      color: #fff;
      padding: .55rem .8rem;
      border-radius: .75rem;
      font-size: .875rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s;
      z-index: 50;
    }

    .show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="app" class="select-none">
    <!-- TOP BAR -->
    <header class="flex justify-between items-center p-3 flex-none">
      <div class="flex items-center gap-2">
        <img src="./icon.svg" alt="TubeTally" class="w-8 h-8" />
        <h1 class="text-xl font-extrabold">TubeTally <span id="appVersionLabel" class="text-xs font-normal align-top opacity-60">vLocal</span></h1>
      </div>
      <div class="flex items-center gap-4">
        <button id="savedFieldsBtn" class="icon-btn" data-surface title="Fields" aria-label="Fields">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
            <path d="M3 10h18"></path>
            <path d="M8 4v4"></path>
          </svg>
          <span class="hidden sm:inline">Fields</span>
        </button>
        <button id="resetBtn" class="icon-btn" data-surface title="New Field" aria-label="New Field">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="1 4 1 10 7 10"></polyline>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
          </svg>
          <span class="hidden sm:inline">New</span>
        </button>
        <button id="settingsBtn" class="icon-btn" data-surface title="Settings" aria-label="Settings">Settings</button>
      </div>
    </header>

    <!-- META ROW -->
        <section id="meta" class="px-4 text-sm flex-none">

      <div class="flex flex-wrap items-center gap-x-2 gap-y-1 w-full">

        <span class="opacity-70">Field:</span>

        <span id="fieldNameLabel" class="font-semibold">-</span>
        <span class="mx-2 opacity-30">&middot;</span>

        <span class="opacity-70">Started:</span>

        <span id="startedAt" class="font-mono">-</span>
        <span id="viewModeBadge" class="hidden ml-auto text-xs uppercase tracking-wide text-green-600 dark:text-green-400">Viewing</span>

      </div>

    </section>

    <!-- MAIN CONTENT (3 COLUMNS) -->
    <div id="mainContent">
      <!-- LEFT COLUMN -->
      <div class="column">
        <!-- HISTORY -->
        <section id="historyWrap" class="flex flex-col flex-1 overflow-hidden">
          <h2 class="font-semibold mt-1 mb-2 flex-none">History</h2>
          <div id="history" class="flex-1 overflow-y-auto card p-2"></div>

          <!-- History stats: compact single-row numeric badges (Slow / Good / Fast) -->
          <div id="historyStats" class="mt-3 text-sm">
            <div class="flex items-center gap-3">
              <div class="flex items-center gap-2">
                <span id="countSlow" class="stat-badge bg-[color:var(--red)] text-white">0</span>
                <span id="countGood" class="stat-badge bg-[color:var(--green)] text-white">0</span>
                <span id="countFast" class="stat-badge bg-[color:var(--yellow)] text-white">0</span>
              </div>
            </div>
          </div>
        </section>
        <!-- BACK BUTTON -->
        <button id="btnBack" class="btn bg-[color:var(--purple)] text-white h-16 text-2xl py-3 mt-2 flex-none">BACK</button>
      </div>

      <!-- CENTER COLUMN: VISUALIZATION -->
      <div class="column flex-none vizColumn" style="width: 3rem;">
        <section id="vizWrap" class="flex flex-col flex-1 overflow-hidden">
          <h2 class="font-semibold mt-1 mb-2 flex-none text-xs text-center opacity-70">Field</h2>
          <svg id="fieldViz" class="flex-1 w-full" style="background: var(--card); border: 1px solid var(--cardBorder); border-radius: 1rem;"></svg>
          <div id="vizLegend" class="mt-2 text-xs space-y-1 flex-none">
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #10B981;"></div>
                <span class="opacity-70">Good</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #EF4444;"></div>
                <span class="opacity-70">Slow</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded" style="background-color: #F59E0B;"></div>
                <span class="opacity-70">Fast</span>
              </div>
          </div>
        </section>
      </div>

      <!-- RIGHT COLUMN -->
      <div class="column">
        <!-- CURRENT ROW -->
        <section id="currentWrap" class="flex flex-col items-center justify-center text-center flex-none mb-2">
          <div class="opacity-70 text-sm">Current Row</div>
          <div id="currentRow" class="text-4xl font-extrabold">1</div>
        </section>

        <!-- PRIMARY BUTTONS -->
        <section id="primaryWrap" class="grid grid-cols-1 gap-3 flex-1 overflow-hidden">
          <button id="btnSlow" class="btn bg-[color:var(--red)] text-white h-full text-4xl py-4">Slow</button>
          <button id="btnGood" class="btn bg-[color:var(--green)] text-white h-full text-4xl py-4">Good</button>
        </section>

        <!-- FAST BUTTON -->
        <button id="btnFast" class="btn bg-[color:var(--yellow)] text-white h-16 text-2xl py-3 mt-3 flex-none">Fast</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS DIALOG -->
  <dialog id="settingsDialog" class="rounded-2xl p-0 w-[28rem] max-w-[95vw]">
    <form id="settingsForm" class="p-5 space-y-4">
      <div class="text-lg font-bold">Settings</div>
      <div class="grid grid-cols-2 gap-4">
      <label class="flex items-center gap-2"><input id="hapticToggle" type="checkbox"
        class="w-5 h-5" /><span>Vibration</span></label>
      <label class="flex items-center gap-2"><input id="beepToggle" type="checkbox"
        class="w-5 h-5" /><span>Beep</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="wakeToggle" type="checkbox"
        class="w-5 h-5" /><span>Keep screen awake</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="darkToggle" type="checkbox"
        class="w-5 h-5" /><span>Dark theme</span></label>
      <label class="flex items-center gap-2 col-span-2"><input id="leftHandedToggle" type="checkbox"
        class="w-5 h-5" /><span>Left-handed layout</span></label>
      </div>
      <div class="border-t border-gray-200 dark:border-gray-700 pt-4 space-y-2">
        <div class="flex items-start justify-between gap-3">
          <div>
            <div class="text-sm font-semibold">Install TubeTally</div>
            <p id="installStatusLabel" class="text-xs opacity-70">Checking install support…</p>
          </div>
          <button type="button" id="installBtn" class="icon-btn bg-[color:var(--purple)] text-white">Install</button>
        </div>
        <button type="button" id="clearAllBtn" class="icon-btn w-full bg-red-600 text-white font-bold text-sm justify-center">Clear all data</button>
      </div>
      <div class="text-xs opacity-60 mt-2" id="settingsVersionLabel">vLocal</div>
    </form>
  </dialog>

  <!-- Field name dialog (opened by clicking the field label) -->
  <dialog id="fieldNameDialog" class="rounded-2xl p-0 w-[22rem] max-w-[95vw]">
    <form id="fieldNameForm" class="p-5 space-y-4">
      <div class="text-lg font-bold">Field Name</div>
      <label class="block">
        <input id="fieldNameDialogInput" class="mt-1 w-full rounded-xl border border-gray-300 p-3 bg-white text-black" placeholder="e.g., West 40 — Block A" />
      </label>
      <div class="flex items-end justify-end">
        <button class="icon-btn bg-[color:var(--green)] text-white font-bold">Save</button>
      </div>
    </form>
  </dialog>

  <!-- New field confirmation dialog -->
  <dialog id="resetConfirmDialog" class="rounded-2xl p-0 w-[24rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div class="text-lg font-bold">Start a new Field?</div>
      <div class="flex gap-2 justify-end">
        <button type="button" class="icon-btn" data-surface onclick="resetConfirmDialog.close()">Cancel</button>
        <button type="submit" class="icon-btn bg-red-600 text-white" value="confirm">New Field</button>
      </div>
    </form>
  </dialog>

  <!-- Change row status dialog -->
  <dialog id="changeRowDialog" class="rounded-2xl p-0 w-[22rem] max-w-[95vw]">
    <div class="p-5 space-y-4">
      <div class="text-lg font-bold">Change Row Status</div>
      <div class="text-sm">
        <div class="mb-1">
          <span class="opacity-50">Row:</span>
          <span id="changeRowNumber" class="font-mono font-bold">—</span>
        </div>
        <div class="flex items-center gap-2">
          <span class="opacity-50">Current:</span>
          <span id="changeRowCurrentBadge" class="history-badge text-white bg-[color:var(--green)] text-sm font-semibold">
            <span id="changeRowCurrent" class="font-semibold">—</span>
          </span>
        </div>
      </div>
      <div class="space-y-2">
        <button type="button" class="icon-btn w-full justify-center bg-[color:var(--yellow)] text-white font-bold text-lg" data-change-status="yellow">
          Fast
        </button>
        <button type="button" class="icon-btn w-full justify-center bg-[color:var(--green)] text-white font-bold text-lg" data-change-status="green">
          Good
        </button>
        <button type="button" class="icon-btn w-full justify-center bg-[color:var(--red)] text-white font-bold text-lg" data-change-status="red">
          Slow
        </button>
      </div>
    </div>
  </dialog>

  <!-- Saved fields dialog -->
  <dialog id="savedFieldsDialog" class="rounded-2xl p-0 w-[32rem] max-w-[95vw]">
    <div class="p-5 flex flex-col gap-3 h-full max-h-[85vh]">
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-lg font-bold leading-tight">Saved Fields</div>
          <p class="text-[0.75rem] opacity-60">Saved Fields stay on this device.</p>
        </div>
      </div>
          <button id="saveFieldBtn" class="icon-btn bg-[color:var(--green)] text-white text-sm font-bold flex items-center gap-2">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
              <polyline points="17 21 17 13 7 13 7 21"></polyline>
              <polyline points="7 3 7 8 15 8"></polyline>
            </svg>
            <span>Save current Field</span>
          </button>
      <div class="card flex-1 overflow-hidden">
        <div id="savedFieldsList" class="p-3 space-y-2 overflow-y-auto max-h-[50vh]"></div>
      </div>
    </div>
  </dialog>

  <!-- Saved field delete confirmation -->
  <dialog id="savedFieldDeleteDialog" class="rounded-2xl p-0 w-[24rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div class="text-lg font-bold">Remove saved field?</div>
      <p class="text-sm opacity-70">This will permanently remove <span id="savedFieldDeleteLabel" class="font-semibold">this field</span> from this device.</p>
      <div class="flex gap-2 justify-end">
        <button type="button" class="icon-btn" data-surface onclick="savedFieldDeleteDialog.close()">Cancel</button>
        <button type="submit" class="icon-btn action-btn action-remove" value="confirm">Remove</button>
      </div>
    </form>
  </dialog>
  <dialog id="confirmDialog" class="rounded-2xl p-0 w-[24rem] max-w-[95vw]">
    <form method="dialog" class="p-5 space-y-4">
      <div id="confirmDialogTitle" class="text-lg font-bold"></div>
      <p id="confirmDialogBody" class="text-sm opacity-70"></p>
      <div class="flex gap-2 justify-end">
        <button type="button" class="icon-btn" data-surface onclick="confirmDialog.close()">Cancel</button>
        <button type="submit" id="confirmDialogPrimary" class="icon-btn bg-red-600 text-white" value="confirm"></button>
      </div>
    </form>
  </dialog>

  <!-- Toast (non-blocking) -->
  <div id="toast" role="status" aria-live="polite">Copied to clipboard</div>

  <script>
    const STORAGE_KEY = 'tubetally.v1';
    window.deferredPrompt = null;
    const SAVED_FIELDS_KEY = 'tubetally.savedFields.v1';
    const MAX_SAVED_FIELDS = 50;
    const $ = s => document.querySelector(s);
    
    // Status mapping: internal codes (color names) map to display labels
    const STATUS_MAP = { 'green': 'Good', 'red': 'Slow', 'yellow': 'Fast' };
    
    const nowLocalISO = () => { const d = new Date(); const p = n => String(n).padStart(2, '0'); return `${d.getFullYear()}-${p(d.getMonth() + 1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}` };

    // Prevent iOS zoom gestures (double-tap/pinch) without affecting Android
    const isIOS = /iP(ad|hone|od)/.test(navigator.userAgent);
    if (isIOS) {
      let lastTouchEnd = 0;
      document.addEventListener('touchend', (event) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
      document.addEventListener('gesturestart', (event) => event.preventDefault(), { passive: false });
    }

    // ---------- Audio ----------
    let audioCtx = null;
    function ensureAudio() { if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch { } } if (audioCtx?.state === 'suspended') { audioCtx.resume?.(); } }
    function beep(freq = 440, dur = 90) { if (!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination); g.gain.setValueAtTime(0.06, audioCtx.currentTime); o.start(); setTimeout(() => { o.stop(); }, dur); }

    // ---------- Haptic ----------
    function vib(pattern) { if (!state.prefs.haptic) return; if (navigator.vibrate) navigator.vibrate(pattern); }
    const hapticPattern = { 'Good': [20, 40, 20], 'Slow': [80], 'Fast': [40, 30, 40], 'UNDO': [30, 20, 30] };

    // ---------- Wake Lock ----------
    let wakeLock = null; async function updateWakeLock() { try { if (state.prefs.wake) { wakeLock = await navigator.wakeLock?.request('screen'); wakeLock?.addEventListener?.('release', () => { }); } else { await wakeLock?.release?.(); wakeLock = null; } } catch { } }
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') updateWakeLock(); });

    // ---------- State ----------
    const initial = { fieldName: '', startedAt: '', currentRow: 1, rows: {}, actions: [], prefs: { haptic: true, beep: true, wake: true, dark: false, leftHanded: false } };
    let state = load();
    let viewMode = false; // true = view-only shared mode, false = normal edit mode
    let viewModeSource = null; // 'share' | 'savedField' | null
    let viewingSavedFieldId = null;
    let savedFieldReturnState = null;
    let savedFieldReturnMeta = null;
    let currentlyEditingSavedFieldId = null;
    let savedFields = loadSavedFields();
    let savedFieldsDialog = null;
    let savedFieldDeleteDialog = null;
    let pendingDeleteSavedFieldId = null;
    let pendingFieldNameAction = null;
    let fieldNameDialog = null;
    let fieldNameInputDialog = null;
    let installBtnEl = null;
    let installStatusEl = null;
    let installStatusState = 'unavailable';
    let confirmDialogEl = null;
    let confirmDialogResolver = null;
    function load() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || { ...initial, startedAt: nowLocalISO() }; } catch { return { ...initial, startedAt: nowLocalISO() }; } }
    function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

    // ---------- Saved fields storage ----------
    function loadSavedFields() { try { return JSON.parse(localStorage.getItem(SAVED_FIELDS_KEY)) || []; } catch { return []; } }
    function persistSavedFields() { try { localStorage.setItem(SAVED_FIELDS_KEY, JSON.stringify(savedFields)); } catch { } }

    const INSTALL_STATUS_MESSAGES = {
      checking: 'Checking install support…',
      available: 'Ready to install from this browser.',
      pending: 'Waiting for browser confirmation…',
      installed: 'App is already installed on this device.',
      unavailable: 'Install prompt not available. Use your browser menu if offered.'
    };

    function setInstallStatus(state, overrideMsg) {
      installStatusState = state;
      const msg = overrideMsg || INSTALL_STATUS_MESSAGES[state] || INSTALL_STATUS_MESSAGES.unavailable;
      if (installStatusEl) installStatusEl.textContent = msg;
      if (installBtnEl) {
        const label = state === 'installed' ? 'Installed' : 'Install';
        installBtnEl.textContent = label;
        installBtnEl.disabled = state !== 'available';
      }
    }

    function attachAutoClose(dialog) {
      if (!dialog) return;
      dialog.addEventListener('click', (event) => {
        if (!dialog.open) return;
        const rect = dialog.getBoundingClientRect();
        const inside = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
        if (!inside) dialog.close();
      });
    }

    function showConfirmDialog({ title = '', body = '', confirmLabel = 'Confirm', confirmColorClass = 'bg-red-600 text-white' }) {
      if (!confirmDialogEl) return Promise.resolve(false);
      return new Promise((resolve) => {
        confirmDialogResolver = resolve;
        $('#confirmDialogTitle').textContent = title;
        $('#confirmDialogBody').textContent = body;
        const primary = document.getElementById('confirmDialogPrimary');
        primary.textContent = confirmLabel;
        primary.className = `icon-btn ${confirmColorClass}`;
        confirmDialogEl.returnValue = '';
        confirmDialogEl.showModal();
      });
    }

    // ---------- Layout calculation ----------
    function layout() {
      // Layout is now handled by flexbox, no complex calculations needed
    }
    window.addEventListener('resize', layout);
    window.addEventListener('orientationchange', () => setTimeout(layout, 200));

    // ---------- Render ----------
    function render(shouldScrollToBottom = false) {
      document.documentElement.classList.toggle('dark', !!state.prefs.dark);
      document.getElementById('app').classList.toggle('flip-layout', !!state.prefs.leftHanded);
      $('#currentRow').textContent = state.currentRow;
      $('#fieldNameLabel').textContent = state.fieldName || '-';
      $('#startedAt').textContent = state.startedAt || '-';
      renderSavedFieldsList();
      const badge = $('#viewModeBadge');
      if (badge) {
        if (viewMode) {
          badge.classList.remove('hidden');
          badge.textContent = viewModeSource === 'savedField' ? 'Viewing saved field' : 'View only';
        } else {
          badge.classList.add('hidden');
        }
      }
      const counts = { green: 0, red: 0, yellow: 0 };
      const h = $('#history');
      const scrollPos = h.scrollTop;
      h.innerHTML = '';
      const keys = Object.keys(state.rows).map(Number).sort((a, b) => a - b);
      for (const n of keys) {
        const st = state.rows[n];
        const stLabel = STATUS_MAP[st] || st;
        if (counts[st] !== undefined) counts[st]++;
        const c = st === 'green' ? 'bg-[color:var(--green)]' : st === 'red' ? 'bg-[color:var(--red)]' : 'bg-[color:var(--yellow)]';
        const d = document.createElement('div');
        d.className = 'border-b' + (document.documentElement.classList.contains('dark') ? ' border-gray-700' : ' border-gray-200') + ' py-2' + (viewMode ? '' : ' cursor-pointer hover:opacity-80 transition-opacity');
        d.style.userSelect = 'none';
        // pad number to 3 digits (non-breaking spaces) and right-align, make badge non-wrapping
        const num = String(n).padStart(3, '\u00A0');
        d.innerHTML = `<div class='history-row w-full'><span class='history-number font-mono opacity-70'>${num}:</span><span class='history-badge text-white ${c}'>${stLabel}</span></div>`;
        if (!viewMode) {
          d.addEventListener('click', () => openChangeRowDialog(n, st));
        }
        h.appendChild(d);
      }
      
      if (shouldScrollToBottom) {
        h.scrollTop = h.scrollHeight;
      } else {
        h.scrollTop = scrollPos;
      }

      // update the small stats under the history
      const elSlow = document.getElementById('countSlow');
      const elGood = document.getElementById('countGood');
      const elFast = document.getElementById('countFast');
      if (elSlow) elSlow.textContent = String(counts['red'] || 0).padStart(3, '\u00A0');
      if (elGood) elGood.textContent = String(counts['green'] || 0).padStart(3, '\u00A0');
      if (elFast) elFast.textContent = String(counts['yellow'] || 0).padStart(3, '\u00A0');

      // Render field visualization
      renderFieldViz();

      // Update visibility based on view mode
      updateViewMode();

      layout();
    }

    function summarizeRows(rows = {}) {
      const totals = { green: 0, red: 0, yellow: 0 };
      if (!rows) return totals;
      for (const status of Object.values(rows)) {
        if (totals[status] !== undefined) totals[status]++;
      }
      return totals;
    }

    function renderSavedFieldsList() {
      const list = document.getElementById('savedFieldsList');
      if (!list) return;
      list.innerHTML = '';
      if (!savedFields.length) {
        const empty = document.createElement('div');
        empty.className = 'saved-field-empty';
        empty.textContent = 'No saved Fields yet';
        list.appendChild(empty);
        return;
      }
      const activeId = viewMode && viewModeSource === 'savedField' ? viewingSavedFieldId : null;
      const editingId = currentlyEditingSavedFieldId;
      for (const field of savedFields) {
        const counts = summarizeRows(field.rows);
        const item = document.createElement('div');
        item.className = 'saved-field-item';
        if (activeId === field.id || editingId === field.id) item.classList.add('active');
        item.dataset.id = field.id;
        const savedText = field.savedAt ? `Saved ${field.savedAt}` : 'Saved field';
        const statusLabel = activeId === field.id ? 'Viewing' : editingId === field.id ? 'Editing' : savedText;
        item.innerHTML = `
          <div class="saved-field-header">
            <div class="saved-field-meta">
              <div class="font-semibold leading-tight">${field.fieldName || 'Untitled field'}</div>
              <div class="text-xs opacity-70">${field.startedAt || '-'}</div>
            </div>
            <div class="saved-field-actions">
              <button type="button" class="icon-btn action-btn action-remove flex items-center gap-1 text-xs font-semibold" title="Remove field" aria-label="Remove field" data-action="delete" data-id="${field.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="3 6 5 6 21 6"></polyline>
                  <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
                  <path d="M10 11v6"></path>
                  <path d="M14 11v6"></path>
                  <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
                </svg>
                <span>Remove</span>
              </button>
            </div>
          </div>
          <div class="saved-field-row">
            <div class="saved-field-stats text-xs font-mono">
              <span class="stat-badge bg-[color:var(--green)] text-white">G ${String(counts.green || 0).padStart(3, '\u00A0')}</span>
              <span class="stat-badge bg-[color:var(--yellow)] text-white">F ${String(counts.yellow || 0).padStart(3, '\u00A0')}</span>
              <span class="stat-badge bg-[color:var(--red)] text-white">S ${String(counts.red || 0).padStart(3, '\u00A0')}</span>
            </div>
            <div class="saved-field-secondary-actions">
              <button type="button" class="icon-btn action-btn action-load flex items-center gap-1 text-xs font-semibold" title="Load field" aria-label="Load field" data-action="load" data-id="${field.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <path d="M7 10l5 5 5-5"></path>
                  <path d="M12 15V3"></path>
                </svg>
                <span>Load</span>
              </button>
              <button type="button" class="icon-btn action-btn action-share flex items-center gap-1 text-xs font-semibold" title="Share field" aria-label="Share field" data-action="share" data-id="${field.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="18" cy="5" r="3"></circle>
                  <circle cx="6" cy="12" r="3"></circle>
                  <circle cx="18" cy="19" r="3"></circle>
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                </svg>
                <span>Share</span>
              </button>
            </div>
          </div>
          <div class="text-[0.7rem] opacity-60 mt-1">${statusLabel}</div>
        `;
        list.appendChild(item);
      }
    }

    // ---------- View Mode ----------
    function updateViewMode() {
      const rightCol = document.querySelector('#mainContent > .column:last-child');
      const vizCol = document.querySelector('.vizColumn');
      const centerCol = document.querySelector('#mainContent > .column:nth-child(2)');
      const historyStats = document.getElementById('historyStats');
      const vizLegend = document.getElementById('vizLegend');
      const backBtn = $('#btnBack');
      const saveFieldBtn = $('#saveFieldBtn');
      const hasRows = Object.keys(state.rows || {}).length > 0;
      if (saveFieldBtn) {
        saveFieldBtn.disabled = viewMode || !hasRows;
        saveFieldBtn.title = viewMode ? 'Exit view mode to save new fields' : (!hasRows ? 'Record at least one row to enable saving' : 'Save this field and reset for the next one');
      }
      
      if (viewMode) {
        // Hide edit controls, show visualization
        rightCol.style.display = 'none'; // Hide entire right column
        centerCol.style.display = ''; // Show visualization
        vizCol.style.width = '30%'; // Make visualization 30% width
        centerCol.style.flex = 'none'; // Reset flex
        historyStats.style.display = 'none';
        if (vizLegend) vizLegend.style.display = '';
        document.getElementById('resetBtn').style.display = 'none';
        document.getElementById('settingsBtn').style.display = 'none';
        backBtn.textContent = viewModeSource === 'savedField' ? 'EDIT FIELD' : 'EDIT';
        backBtn.onclick = () => toggleViewMode(); // Change handler to toggle view mode
        // Re-render to account for new width
        setTimeout(() => renderFieldViz(), 0);
      } else {
        // Show all controls
        rightCol.style.display = ''; // Show entire right column
        centerCol.style.display = '';
        vizCol.style.width = '3rem'; // Reset to thin width
        centerCol.style.flex = ''; // Reset flex
        historyStats.style.display = '';
        if (vizLegend) vizLegend.style.display = 'none';
        document.getElementById('resetBtn').style.display = '';
        document.getElementById('settingsBtn').style.display = '';
        backBtn.textContent = 'BACK'; // Change button text back to BACK
        backBtn.onclick = () => undo(); // Change handler back to undo
        // Re-render to account for new width
        setTimeout(() => renderFieldViz(), 0);
      }
    }

    function toggleViewMode() {
      if (!viewMode) return;
      if (viewModeSource === 'savedField') {
        currentlyEditingSavedFieldId = viewingSavedFieldId;
        savedFieldReturnState = null;
        savedFieldReturnMeta = null;
        viewingSavedFieldId = null;
        viewModeSource = null;
        viewMode = false;
        save();
        render();
        showToast('Editing field');
        return;
      }
      if (savedFieldReturnState) {
        state = savedFieldReturnState;
        savedFieldReturnState = null;
        currentlyEditingSavedFieldId = savedFieldReturnMeta?.editingId || null;
        savedFieldReturnMeta = null;
        viewingSavedFieldId = null;
        viewModeSource = null;
        viewMode = false;
        save();
        render();
        return;
      }
      savedFieldReturnState = null;
      savedFieldReturnMeta = null;
      viewingSavedFieldId = null;
      viewModeSource = null;
      viewMode = false;
      render();
    }

    // ---------- Saved Fields ----------
    function nextRowFromRows(rows = {}) {
      const keys = Object.keys(rows || {}).map(k => parseInt(k, 10)).filter(n => !isNaN(n));
      if (!keys.length) return 1;
      return Math.max(...keys) + 1;
    }

    function saveCurrentField() {
      if (viewMode) {
        showToast('Exit view mode to save fields');
        return;
      }
      const hasRows = Object.keys(state.rows || {}).length;
      if (!hasRows) {
        showToast('No rows recorded yet');
        return;
      }
      if (!state.fieldName) {
        pendingFieldNameAction = 'saveField';
        if (fieldNameInputDialog) {
          fieldNameInputDialog.value = state.fieldName || '';
          setTimeout(() => fieldNameInputDialog?.focus(), 0);
        }
        fieldNameDialog?.showModal();
        return;
      }
      const editingId = currentlyEditingSavedFieldId;
      const snapshot = {
        id: editingId || `${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
        fieldName: state.fieldName || `Field ${savedFields.length + 1}`,
        startedAt: state.startedAt || nowLocalISO(),
        savedAt: nowLocalISO(),
        rows: { ...state.rows },
        currentRow: state.currentRow
      };
      savedFields = savedFields.filter(f => f.id !== snapshot.id);
      savedFields.unshift(snapshot);
      if (savedFields.length > MAX_SAVED_FIELDS) savedFields = savedFields.slice(0, MAX_SAVED_FIELDS);
      persistSavedFields();
      renderSavedFieldsList();
      showToast(editingId ? 'Field updated' : 'Field saved');
      currentlyEditingSavedFieldId = null;
      resetNow();
    }

    function deleteSavedField(id) {
      const idx = savedFields.findIndex(f => f.id === id);
      if (idx === -1) return;
      const removed = savedFields[idx];
      savedFields.splice(idx, 1);
      persistSavedFields();
      if (viewMode && viewModeSource === 'savedField' && viewingSavedFieldId === id) {
        toggleViewMode();
      } else {
        renderSavedFieldsList();
      }
      showToast('Field removed');
      return removed;
    }

    function requestDeleteSavedField(id) {
      const entry = savedFields.find(f => f.id === id);
      if (!entry || !savedFieldDeleteDialog) return;
      pendingDeleteSavedFieldId = id;
      const label = entry.fieldName || 'this field';
      const labelEl = document.getElementById('savedFieldDeleteLabel');
      if (labelEl) labelEl.textContent = label;
      savedFieldDeleteDialog.showModal();
    }

    function viewSavedField(id) {
      if (!id) return;
      if (viewMode && viewModeSource === 'savedField' && viewingSavedFieldId === id) return;
      const entry = savedFields.find(f => f.id === id);
      if (!entry) return;
      if (viewModeSource !== 'savedField' || !savedFieldReturnState) {
        savedFieldReturnState = state;
        savedFieldReturnMeta = { editingId: currentlyEditingSavedFieldId };
      }
      currentlyEditingSavedFieldId = null;
      const prefsSource = savedFieldReturnState ? savedFieldReturnState.prefs : state.prefs;
      state = {
        ...initial,
        fieldName: entry.fieldName || '',
        startedAt: entry.startedAt || '',
        rows: { ...entry.rows },
        actions: [],
        currentRow: entry.currentRow || nextRowFromRows(entry.rows),
        prefs: { ...prefsSource }
      };
      viewMode = true;
      viewModeSource = 'savedField';
      viewingSavedFieldId = entry.id;
      if (savedFieldsDialog?.open) savedFieldsDialog.close();
      render(true);
      showToast(`Viewing ${entry.fieldName || 'saved field'}`);
    }

    // ---------- Field Visualization ----------
    function renderFieldViz() {
      const svg = $('#fieldViz');
      if (!svg) return;
      
      const svgRect = svg.getBoundingClientRect();
      const width = svgRect.width || 48;
      const height = svgRect.height || 400;
      
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.innerHTML = '';
      
      const keys = Object.keys(state.rows).map(Number).sort((a, b) => a - b);
      const totalRows = Math.max(state.currentRow - 1, 50); // Assume minimum 50 rows
      const rowHeight = height / totalRows;
      
      // Draw each logged row as a colored band
      for (const rowNum of keys) {
        const status = state.rows[rowNum];
        const color = status === 'green' ? '#10B981' : status === 'red' ? '#EF4444' : '#F59E0B';
        
        const y = (rowNum - 1) * rowHeight;
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', rowHeight);
        rect.setAttribute('fill', color);
        rect.style.opacity = '0.85';
        svg.appendChild(rect);
      }
      
      // Draw a line at the current row position
      const currentY = (state.currentRow - 1) * rowHeight;
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', '0');
      line.setAttribute('y1', currentY);
      line.setAttribute('x2', width);
      line.setAttribute('y2', currentY);
      line.setAttribute('stroke', '#6B7280');
      line.setAttribute('stroke-width', '2');
      line.style.opacity = '0.5';
      svg.appendChild(line);
    }

    // ---------- Actions ----------
    function record(status) {
      if (viewMode) {
        showToast('Viewing saved field');
        return;
      }
      ensureAudio();
      const label = STATUS_MAP[status] || status;
      if (state.prefs.haptic) vib(hapticPattern[label]);
      if (state.prefs.beep && audioCtx) beep(status === 'green' ? 700 : status === 'red' ? 300 : 520, 100);
      state.rows[state.currentRow] = status;
      state.actions.push(state.currentRow);
      state.currentRow++;
      save();
      render(true);
    }
    function undo() {
      if (viewMode) {
        toggleViewMode();
        return;
      }
      ensureAudio();
      const last = state.actions.pop();
      if (!last) return;
      if (state.prefs.haptic) vib(hapticPattern.UNDO);
      if (state.prefs.beep && audioCtx) beep(250, 110);
      delete state.rows[last];
      state.currentRow = last;
      save();
      render(true);
    }

    // Long-press to test tone/haptic without recording
    function addHoldTest(el, status) {
      let t = null; el.addEventListener('pointerdown', () => { t = setTimeout(() => { ensureAudio(); const label = STATUS_MAP[status] || status; if (state.prefs.haptic) vib(hapticPattern[label]); if (state.prefs.beep && audioCtx) beep(status === 'green' ? 700 : status === 'red' ? 300 : 520, 200); t = null; }, 550); }, { passive: true });
      ['pointerup', 'pointercancel', 'pointerleave'].forEach(ev => el.addEventListener(ev, () => { if (t) { clearTimeout(t); t = null; } }, { passive: true }));
    }

    // ---------- Report ----------
    function buildReport(data = state) {
      const rows = data.rows || {};
      const tempState = { rows, currentRow: Object.keys(rows).length + 1, fieldName: data.fieldName || state.fieldName, startedAt: data.startedAt || nowLocalISO() };
      const b = { 'green': [], 'yellow': [], 'red': [] };
      for (const [k, v] of Object.entries(rows)) if (b[v]) b[v].push(+k);
      for (const k in b) b[k].sort((a, b) => a - b);
      const cG = b['green'].length, cF = b['yellow'].length, cS = b['red'].length;
      const header = `Field: ${tempState.fieldName || '—'}\nDate: ${tempState.startedAt || nowLocalISO()}`;
      const body = [`Good (${cG} rows): ${b['green'].join(', ')}`, '', `Fast (${cF} rows): ${b['yellow'].join(', ')}`, '', `Slow (${cS} rows): ${b['red'].join(', ')}`].join('\n');
      return `${header}\n\n${body}`;
    }

    function compressData(rows) {
      // Convert rows object to compact string: "1:G,2:R,3:Y" format (green/red/yellow)
      const parts = [];
      for (let i = 1; i < state.currentRow; i++) {
        if (rows[i]) {
          const status = rows[i];
          const char = status === 'green' ? 'G' : status === 'red' ? 'R' : 'Y';
          parts.push(`${i}:${char}`);
        }
      }
      return parts.join(',');
    }

    function decompressData(compressed) {
      const rows = {};
      if (!compressed) return rows;
      const parts = compressed.split(',');
      for (const part of parts) {
        const [rowStr, char] = part.split(':');
        const rowNum = parseInt(rowStr, 10);
        const status = char === 'G' ? 'green' : char === 'R' ? 'red' : 'yellow';
        rows[rowNum] = status;
      }
      return rows;
    }

    function buildShareUrl(data = state) {
      // Compress data: field name and compressed rows
      const compressed = compressData(data.rows || {});
      const payload = `${data.fieldName || 'Field'}|${data.startedAt || ''}|${compressed}`;
      const encoded = btoa(payload).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      // Generate full URL with hash, works for both file:// and http(s)://
      const currentUrl = window.location.href.split('#')[0]; // Remove any existing hash
      return `${currentUrl}#d=${encoded}`;
    }

    function loadFromShareUrl() {
      const fullHash = window.location.hash;
      console.log('Full hash:', fullHash);
      if (!fullHash || !fullHash.includes('d=')) return false;
      
      try {
        // Extract the hash portion after #
        let encoded = fullHash.substring(fullHash.indexOf('d=') + 2);
        console.log('Encoded:', encoded);
        
        // Restore padding for base64
        encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');
        // Add padding as needed
        while (encoded.length % 4) encoded += '=';
        console.log('After padding:', encoded);
        
        const data = atob(encoded);
        console.log('Decoded data:', data);
        
        const parts = data.split('|');
        const fieldName = parts[0];
        const startedAt = parts[1];
        const compressed = parts[2];
        
        console.log('Parsed:', { fieldName, startedAt, compressed });
        
        if (fieldName !== undefined) {
          state.fieldName = fieldName === 'Field' ? '' : fieldName;
          state.startedAt = startedAt || nowLocalISO();
          state.rows = decompressData(compressed);
          state.currentRow = Math.max(...Object.keys(state.rows).map(Number), 0) + 1 || 1;
          console.log('Loaded state:', state);
          viewMode = true; // Enable view mode for shared URLs
          viewModeSource = 'share';
          viewingSavedFieldId = null;
          currentlyEditingSavedFieldId = null;
          savedFieldReturnState = null;
          savedFieldReturnMeta = null;
          save();
          return true;
        }
      } catch (err) {
        console.error('Failed to load from share URL:', err);
      }
      return false;
    }

    // Share: native sheet when available; else copy silently with toast (no blocking prompts)
    async function shareReport(data = state) { 
      const url = buildShareUrl(data);
      const text = buildReport(data) + '\n\n' + url;
      if (navigator.share) { 
        try { 
          await navigator.share({ title: 'TubeTally Report', text }); 
          return; 
        } catch { return; } 
      } 
      try { 
        await navigator.clipboard.writeText(text); 
        showToast('Copied to clipboard'); 
      } catch { /* ignore */ } 
    }

    function showToast(msg) { const el = $('#toast'); el.textContent = msg; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 1500); }

    // Reset: clears field-name/rows/status and storage; preserves preferences
    async function resetNow() {
      const prefsCopy = { ...state.prefs };
      viewMode = false;
      viewModeSource = null;
      viewingSavedFieldId = null;
      savedFieldReturnState = null;
      savedFieldReturnMeta = null;
      currentlyEditingSavedFieldId = null;
      state = { ...initial, fieldName: '', startedAt: nowLocalISO(), prefs: prefsCopy, rows: {}, actions: [] };
      try { localStorage.removeItem(STORAGE_KEY); } catch { }
      save();
      render();
    }
    async function clearAllData() {
      const confirmed = await showConfirmDialog({
        title: 'Clear all data?',
        body: 'This removes all saved Fields, preferences, cached versions, and reloads the app.',
        confirmLabel: 'Clear everything',
        confirmColorClass: 'bg-red-700 text-white'
      });
      if (!confirmed) return;
      const keys = Object.keys(localStorage).filter(k => k.startsWith('tubetally.'));
      for (const k of keys) {
        try { localStorage.removeItem(k); } catch { }
      }
      try {
        const registrations = await navigator.serviceWorker?.getRegistrations?.();
        if (registrations?.length) {
          await Promise.allSettled(registrations.map(r => r.unregister()));
        }
      } catch { }
      location.reload(true);
    }

    // ---------- Change Row Dialog ----------
    let changeRowDialogData = { rowNum: null, oldStatus: null };
    function openChangeRowDialog(rowNum, currentStatus) {
      changeRowDialogData = { rowNum, oldStatus: currentStatus };
      $('#changeRowNumber').textContent = rowNum;
      $('#changeRowCurrent').textContent = (STATUS_MAP[currentStatus] || currentStatus);
      const badge = document.getElementById('changeRowCurrentBadge');
      if (badge) {
        badge.classList.remove('bg-[color:var(--green)]', 'bg-[color:var(--red)]', 'bg-[color:var(--yellow)]');
        badge.classList.add(currentStatus === 'red' ? 'bg-[color:var(--red)]' : currentStatus === 'yellow' ? 'bg-[color:var(--yellow)]' : 'bg-[color:var(--green)]');
      }
      document.getElementById('changeRowDialog').showModal();
    }
    function changeRowStatus(newStatus) {
      if (viewMode) return;
      if (changeRowDialogData.rowNum === null) return;
      state.rows[changeRowDialogData.rowNum] = newStatus;
      save();
      render(false);
      document.getElementById('changeRowDialog').close();
    }

    // ---------- Bindings ----------
    $('#btnGood').onclick = () => record('green');
    $('#btnSlow').onclick = () => record('red');
    $('#btnFast').onclick = () => record('yellow');
    $('#btnBack').onclick = () => undo();
    addHoldTest($('#btnGood'), 'green');
    addHoldTest($('#btnSlow'), 'red');
    addHoldTest($('#btnFast'), 'yellow');

    confirmDialogEl = document.getElementById('confirmDialog');
    if (confirmDialogEl) window.confirmDialog = confirmDialogEl;
    if (confirmDialogEl) {
      confirmDialogEl.addEventListener('close', () => {
        const didConfirm = confirmDialogEl.returnValue === 'confirm';
        if (confirmDialogResolver) confirmDialogResolver(didConfirm);
        confirmDialogResolver = null;
      });
    }

    const saveFieldBtnEl = document.getElementById('saveFieldBtn');
    if (saveFieldBtnEl) saveFieldBtnEl.addEventListener('click', () => { ensureAudio(); saveCurrentField(); });
    const savedFieldsListEl = document.getElementById('savedFieldsList');
    if (savedFieldsListEl) {
      savedFieldsListEl.addEventListener('click', (event) => {
        const deleteBtn = event.target.closest('[data-action="delete"]');
        if (deleteBtn) {
          event.stopPropagation();
          requestDeleteSavedField(deleteBtn.dataset.id);
          return;
        }
        const shareBtn = event.target.closest('[data-action="share"]');
        if (shareBtn) {
          event.stopPropagation();
          const entry = savedFields.find(f => f.id === shareBtn.dataset.id);
          if (entry) {
            ensureAudio();
            shareReport({
              fieldName: entry.fieldName,
              startedAt: entry.startedAt,
              rows: entry.rows
            });
          }
          return;
        }
        const loadBtn = event.target.closest('[data-action="load"]');
        if (loadBtn) {
          ensureAudio();
          viewSavedField(loadBtn.dataset.id);
          return;
        }
      });
    }

    // Change row status dialog handlers
    document.querySelectorAll('[data-change-status]').forEach(btn => {
      btn.addEventListener('click', () => {
        const status = btn.getAttribute('data-change-status');
        changeRowStatus(status);
        document.getElementById('changeRowDialog').close();
      });
    });

    savedFieldsDialog = document.getElementById('savedFieldsDialog');
    attachAutoClose(savedFieldsDialog);
    const changeRowDialog = document.getElementById('changeRowDialog');
    attachAutoClose(changeRowDialog);
    if (savedFieldsDialog) {
      const savedFieldsBtn = document.getElementById('savedFieldsBtn');
      if (savedFieldsBtn) savedFieldsBtn.addEventListener('click', () => {
        ensureAudio();
        renderSavedFieldsList();
        savedFieldsDialog.showModal();
      });
    }
    
    savedFieldDeleteDialog = document.getElementById('savedFieldDeleteDialog');
    if (savedFieldDeleteDialog) {
      window.savedFieldDeleteDialog = savedFieldDeleteDialog;
      savedFieldDeleteDialog.addEventListener('close', () => {
        if (savedFieldDeleteDialog.returnValue === 'confirm' && pendingDeleteSavedFieldId) {
          deleteSavedField(pendingDeleteSavedFieldId);
        }
        pendingDeleteSavedFieldId = null;
      });
    }

    installBtnEl = document.getElementById('installBtn');
    installStatusEl = document.getElementById('installStatusLabel');
    const isStandalone = !!(window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || window.navigator?.standalone;
    setInstallStatus(isStandalone ? 'installed' : 'unavailable');
    if (installBtnEl) {
      installBtnEl.addEventListener('click', async () => {
        ensureAudio();
        if (!window.deferredPrompt) {
          setInstallStatus('unavailable', 'Install prompt not available right now. Use your browser menu to install.');
          return;
        }
        try {
          window.deferredPrompt.prompt();
          setInstallStatus('pending');
          const choice = await window.deferredPrompt.userChoice;
          window.deferredPrompt = null;
          if (choice.outcome === 'accepted') {
            setInstallStatus('pending', 'Install prompt accepted. Waiting for browser…');
          } else {
            setInstallStatus('unavailable', 'Install dismissed. You can try again later.');
          }
        } catch (err) {
          console.warn('install prompt error', err);
          setInstallStatus('unavailable', 'Install failed. Try again later.');
        }
      });
    }
    
    // Reset button: show confirmation dialog instead of immediately resetting
    const resetConfirmDialog = document.getElementById('resetConfirmDialog');
    attachAutoClose(resetConfirmDialog);
    $('#resetBtn').onclick = () => {
      resetConfirmDialog.showModal();
    };
    resetConfirmDialog.addEventListener('close', (e) => {
      if (resetConfirmDialog.returnValue === 'confirm') {
        resetNow();
        showToast('New Field started');
      }
    });

    // Settings dialog
    const settingsDialog = document.getElementById('settingsDialog');
    attachAutoClose(settingsDialog);
    const clearAllBtnEl = document.getElementById('clearAllBtn');
    if (clearAllBtnEl) clearAllBtnEl.addEventListener('click', () => { ensureAudio(); clearAllData(); });
    $('#settingsBtn').onclick = () => {
      $('#hapticToggle').checked = !!state.prefs.haptic;
      $('#beepToggle').checked = !!state.prefs.beep;
      $('#wakeToggle').checked = !!state.prefs.wake;
      $('#darkToggle').checked = !!state.prefs.dark;
      $('#leftHandedToggle').checked = !!state.prefs.leftHanded;
      settingsDialog.showModal();
    };
    const settingsFormEl = document.getElementById('settingsForm');
    const applySettings = () => {
      state.prefs.haptic = $('#hapticToggle').checked;
      state.prefs.beep = $('#beepToggle').checked;
      state.prefs.wake = $('#wakeToggle').checked;
      state.prefs.dark = $('#darkToggle').checked;
      state.prefs.leftHanded = $('#leftHandedToggle').checked;
      if (!state.startedAt) state.startedAt = nowLocalISO();
      save(); render(); updateWakeLock();
    };
    ['change', 'input'].forEach(ev => settingsFormEl.addEventListener(ev, applySettings));

    // Field name dialog bindings (opened by clicking the field label)
    fieldNameDialog = document.getElementById('fieldNameDialog');
    if (fieldNameDialog?.open) fieldNameDialog.close();
    // also expose on window so inline onclick="fieldNameDialog.close()" works
    window.fieldNameDialog = fieldNameDialog;
    fieldNameInputDialog = document.getElementById('fieldNameDialogInput');
    document.getElementById('fieldNameLabel').addEventListener('click', () => {
      if (viewMode) return;
      fieldNameInputDialog.value = state.fieldName || '';
      fieldNameDialog.showModal();
    });
    document.getElementById('fieldNameForm').addEventListener('submit', (e) => {
      e.preventDefault();
      state.fieldName = fieldNameInputDialog.value.trim();
      if (!state.startedAt) state.startedAt = nowLocalISO();
      save();
      render();
      const pendingAction = pendingFieldNameAction;
      pendingFieldNameAction = null;
      fieldNameDialog.returnValue = 'submit';
      fieldNameDialog.close();
      if (pendingAction === 'saveField' && state.fieldName) {
        setTimeout(() => saveCurrentField(), 0);
      }
    });
    if (fieldNameDialog) {
      fieldNameDialog.addEventListener('close', () => {
        if (fieldNameDialog.returnValue !== 'submit') {
          pendingFieldNameAction = null;
        }
        fieldNameDialog.returnValue = '';
      });
    }

    // Prime audio on first interaction
    document.addEventListener('touchstart', ensureAudio, { once: true });
    document.addEventListener('mousedown', ensureAudio, { once: true });

    const isShared = loadFromShareUrl();
    render(isShared);
    if (isShared) {
      // Delay toast slightly to ensure DOM is ready
      setTimeout(() => showToast('Report loaded from URL'), 100);
    }
    updateWakeLock();

    // load version from single source (src/version.json)
    (async function loadVersion(){
      try {
        // Always bypass caches when checking version.json
        const res = await fetch('./version.json', {cache: 'no-store'});
        if (!res.ok) return;
        const data = await res.json();
        const ver = data.version || '';
        const appVerEl = document.getElementById('appVersionLabel');
        const settingsVerEl = document.getElementById('settingsVersionLabel');
        const formattedVer = ver ? `v${ver}` : '';
        if (appVerEl) appVerEl.textContent = formattedVer;
        if (settingsVerEl) settingsVerEl.textContent = formattedVer;

        // If the version changed since last load, perform a single cache-busting reload.
        // This avoids requiring users to use DevTools -> Empty Cache and Hard Reload.
        try {
          const last = localStorage.getItem('tubetally.cachedVersion') || '';
          if (last !== ver) {
            // store new version
            localStorage.setItem('tubetally.cachedVersion', ver);
            // Only trigger a reload once per session to avoid loops
            const sessionKey = 'tubetally.reloadedFor';
            const already = sessionStorage.getItem(sessionKey);
            if (already !== ver) {
              sessionStorage.setItem(sessionKey, ver);
              // Build a cache-busting URL (preserve hash)
              const base = window.location.href.split('#')[0].split('?')[0];
              const hash = window.location.hash || '';
              const cbUrl = `${base}?cb=${Date.now()}${hash}`;
              // Use replace to avoid creating history entries
              window.location.replace(cbUrl);
            }
          }
        } catch (e) {
          console.warn('version reload check failed', e);
        }

      } catch (err) {
        console.warn('Failed to load version.json', err);
      }
    })();
    
    // Scroll history to bottom on page load
    setTimeout(() => {
      const h = $('#history');
      if (h) h.scrollTop = h.scrollHeight;
    }, 0);
  </script>
  <script>
    // Register service worker for offline support and installability
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js').then(() => {
        console.log('Service worker registered');
      }).catch((err) => {
        console.warn('Service worker registration failed:', err);
      });
    }

    // Optional: capture install prompt for custom UI and wire the Install button
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      window.deferredPrompt = e;
      setInstallStatus('available');
      console.log('beforeinstallprompt captured');
    });

    window.addEventListener('appinstalled', (e) => {
      window.deferredPrompt = null;
      setInstallStatus('installed');
      showToast('App installed');
    });
  </script>
</body>

</html>
